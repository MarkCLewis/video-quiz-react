package controllers

import javax.inject._

import shared.SharedData._
import play.api.mvc._
import play.api.libs.json.Json
import play.api.db.slick.DatabaseConfigProvider
import play.api.db.slick.HasDatabaseConfigProvider
import scala.concurrent.ExecutionContext
import slick.jdbc.JdbcProfile
import slick.jdbc.JdbcCapabilities
import slick.jdbc.MySQLProfile.api._
import scala.concurrent.Future
import java.time.LocalDateTime
import models.Tables._
import java.sql.Timestamp
import play.api.libs.json.JsSuccess
import play.api.libs.json.JsError
import play.api.libs.json.Reads

@Singleton
class Application @Inject()(
  protected val dbConfigProvider: DatabaseConfigProvider,
  cc: ControllerComponents)(implicit ec: ExecutionContext)
  extends AbstractController(cc) with HasDatabaseConfigProvider[JdbcProfile] {  

  import ControlHelpers._

  implicit val actionBuilder = Action

  def index = Action { implicit request =>
    Ok(views.html.index())
  }

  /**
    * This method is removes the boilerplate that is associated with pulling data out of a post request.
    *
    * @param f The function that is executed with the body to build the response.
    * @param request The request containing the body.
    * @param reads An implicit converter from Json.
    * @return A future of a result that is generated by the function or a redirect to the initial page.
    */
  def withJsonBody[A](f: A => Future[Result])(implicit request: Request[AnyContent], reads: Reads[A]): Future[Result] = {
    request.body.asJson.map { body =>
      Json.fromJson[A](body) match {
        case JsSuccess(a, path) => f(a)
        case e @ JsError(_) => Future(Redirect(routes.Application.index()))
      }
    }.getOrElse(Future(Redirect(routes.Application.index())))
  }

  def tryLogin = Action.async { implicit request =>
    withJsonBody[LoginInfo] { li =>
      models.Queries.validLogin(li.username, li.password, db).flatMap { uid => 
        uid match {
          case -1 =>
          Future(Ok(Json.toJson(UserData(li.username, uid, scala.util.Random.nextInt(), false))))
          case n =>
          val instructorCourses = models.Queries.instructorCourseIds(n, db)
          instructorCourses.map(_ match {
            case Seq() =>
              val ud = UserData(li.username, uid, scala.util.Random.nextInt(), false)
              Ok(Json.toJson(ud)).withSession(request.session + ("username" -> li.username) + ("userid" -> n.toString))
            case _ =>
              val ud = UserData(li.username, uid, scala.util.Random.nextInt(), true)
              Ok(Json.toJson(ud)).withSession(request.session + ("username" -> li.username) + ("userid" -> n.toString) + ("instructor" -> "yes"))
          })
        }
      }
    }
  }

  def getCourses = AuthenticatedAction { implicit request =>
    withJsonBody[Int] { userid => 
      models.Queries.coursesFor(userid, db).map { crs =>
        val courses = crs.map { case (cr, role) => CourseData(cr.code+"-"+cr.section+"-"+cr.semester, cr.courseid, role) }
        Ok(Json.toJson(courses))
      }
    }
  }

  def getQuizzes = AuthenticatedAction { implicit request =>
    withJsonBody[Int] { courseid =>
      models.Queries.allQuizzesForClass(courseid, db).map { quizAndTime => 
        val quizData = quizAndTime.map { case (q, t) => QuizTimeData(q.quizid, q.name, q.description, t.toString) }
        Ok(Json.toJson(quizData))
      }
    }
  }

  def getQuizData = AuthenticatedAction { implicit request =>
    withJsonBody[(Int, Int)] { case (quizid, userid) =>
      models.Queries.quizData(quizid, userid, db).map { qd =>
        Ok(Json.toJson(qd))
      }
    }
  }

  def submitMC = AuthenticatedAction { implicit request =>
    withJsonBody[(Int, Int, Int, Int)] { case (quizid, userid, mcid, selection) =>
      models.ProblemSpecRunner.multipleChoice(mcid, db).flatMap { spec =>
        val c = models.ProblemSpecRunner.checkResponse(spec, selection.toString)
        db.run(McAnswers += McAnswersRow(Some(userid), Some(quizid), Some(mcid), selection, c.correct, Timestamp.valueOf(LocalDateTime.now())))
          .map(_ => Ok(Json.toJson(c)))
      }
    }
  }

  def submitCode = AuthenticatedAction { implicit request =>
    withJsonBody[(Int, Int, Int, Int, String)] { case (quizid, userid, codeid, qtype, code) =>
      models.ProblemSpecRunner(qtype, codeid, db).flatMap { spec =>
        val c = models.ProblemSpecRunner.checkResponse(spec, code)
        db.run(CodeAnswers += CodeAnswersRow(Some(userid), Some(quizid), codeid.toInt, qtype.toInt, code, c.correct, Timestamp.valueOf(LocalDateTime.now())))
          .map(_ => Ok(Json.toJson(c)))
      }
    }
  }
}
